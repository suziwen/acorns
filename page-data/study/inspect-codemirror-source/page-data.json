{"componentChunkName":"component---node-modules-suziwen-gatsby-theme-sculpting-src-templates-template-blog-post-js","path":"/study/inspect-codemirror-source","result":{"data":{"zipFile":{"publicURL":"/acorns/static/42be1f07efee5cfa91907768ea78aef4/CodeMirror 内部代码的研究.zip"},"site":{"siteMetadata":{"siteUrl":"https://suziwen.github.io/acorns"}},"storyWriterMarkdown":{"id":"bedc84ab-8369-5b26-8bc6-bcefc5b79776","html":"\n\n\t<div class=\"preview html_preview xsj_export_zip\"><div style=\"overflow: hidden; position: absolute; top: 0; height: 1px; width: auto; padding: 0; border: 0; margin: 0; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal;\"><svg><defs id=\"MathJax_SVG_glyphs\"/></svg></div><p class=\"xsj_paragraph xsj_paragraph_level_0\"><a href=\"https://codemirror.net/doc/manual.html#modeapi\" class=\"xsj_link xsj_manu_link\">官方提供的教程</a></p>\n<p class=\"xsj_paragraph xsj_paragraph_level_0\">defineMode 里有使用到的方法</p>\n<p class=\"xsj_paragraph xsj_paragraph_level_0\">nestMode 的定义和 mixMode addon 有什么区别呢？为什么不能在 markdonw Mode 里直接 nestMode texmode 而是要建议用 mixMode</p>\n<h2 class=\"xsj_heading_hash xsj_heading xsj_heading_h2\" id=\"addonmodeloverlayjs20e6ba90e4bba3e7a081e58886e69e90_1\"><div class=\"xiaoshujiang_element xsj_anchor\">\n  <a name=\"addonmodeloverlayjs20e6ba90e4bba3e7a081e58886e69e90_1\" class=\"blank_anchor_name\"></a><a id=\"addonmodeloverlayjs20e6ba90e4bba3e7a081e58886e69e90_1\" class=\"blank_anchor_id\"></a><a name=\"addonmodeloverlayjs-源代码分析\" class=\"blank_anchor_name\"></a><a id=\"addonmodeloverlayjs-源代码分析\" class=\"blank_anchor_id\"></a>\n</div>\n<span class=\"xsj_heading_content\">addon/model/overlay.js 源代码分析</span></h2>\n<p class=\"xsj_paragraph xsj_paragraph_level_0\"><code>addon/model/overlay.js</code> 里的 <code>overlayMode</code> 方法大概的实际效果：</p>\n<p class=\"xsj_paragraph xsj_paragraph_level_0\">两个 mode 同时分析一行，各自分析各自的，其中一个是 baseMode, 一个是 overlayMode , 如果 overlayMode 和 baseMode 在某一个 position 重叠，同时配置的 combine 参数是 false, 并且 overlayMode 的返回结果不是空的话，就会覆盖 baseMode 的结果，如果 combine 参数是 true, 就会把 overlayMode 的结果合并到 baseMode 里。</p>\n<p class=\"xsj_paragraph xsj_paragraph_level_0\">比如下面的代码, 我们在 CodeMirror 官方介绍 overlayMode 的 <a href=\"https://codemirror.net/demo/mustache.html\" class=\"xsj_link xsj_manu_link\">demo</a> 里测试的话，就会披到结尾的 <code>&lt;/div&gt;</code> 是个错误的提示。</p>\n<div class=\"xiaoshujiang_code_container\"><div data-processed=\"true\" class=\"xiaoshujiang_pre\"><div class=\"language-html hljs xml code_linenums xiaoshujiang_code\"><ol start=\"1\" class=\"ol_linenums\" style=\"counter-reset: lines 0;\"><li class=\"li_linenum \" date-linenum=\"1\"><span class=\"li_linenum_before_span li_linenum_before_span_hide\">1</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>{{<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>}}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><span style=\"user-select:none;display:none;\">&nbsp;</span><br class=\"code_line_break_hack_br\"><hr class=\"code_line_break_hack_hr code_line_break_hack\" style=\"margin:0;border:0;border-top:0;border-bottom:0;\"></li></ol></div></div></div>\n<p class=\"xsj_paragraph xsj_paragraph_level_0\"></p><div class=\"story_image_container story_block_image\"><div class=\"story_image\"><div class=\"gatsby-wrapper-image\" style=\"display:inline-block;max-width: 100%;width:235px; margin-left: auto; margin-right: auto;position:relative;\"><div style=\"width:100%;display:block;padding-bottom: 30.21276595744681%;\"></div><img class=\"background_image\" src=\"data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='400'%20height='121'%3e%3cpath%20d='M13%2018a1590%201590%200%20001%2052l1-50h192l193-1c0-2-22-2-193-2L13%2018m258%2016v8l-5-2-5-1c0%201%201%202%203%202%203%201%203%203%200%204s-5%204-2%203l5-2%204-2v6l1%207%201-15-1-16-1%208M41%2036c0%202%200%203-2%202-4-1-7%207-3%2010l4%202h3v-9l-1-8-1%203m191%200l-2%202c-4%200-5%202-5%206s1%206%206%206h3v-8l-1-9-1%203m-4%2041l-2%203c0%202-2%202-18%202s-19%200-19%202c-2%203%200%203%2015%203l14%201-7%209c-8%207-12%2014-10%2017%201%203%204%202%205-2%201-3%2015-19%2017-19l1%2014c0%2012%201%2014%202%2014%203%200%204-2%204-9%200-8%201-9%203-3%201%204%206%209%208%209s2-3%200-6l-11-22%201-2%2039-1c31%200%2039-1%2039-2v-2l-39-1c-38%200-39%200-38-2%202-4-1-7-4-3'%20fill='%23d3d3d3'%20fill-rule='evenodd'/%3e%3c/svg%3e\" style=\"position: absolute;top:0;left:0;width: 100%;height:100%;object-fit: cover;object-position: center;\"><img src=\"/acorns/static/234aba69c9e8ddcd2451a33bc0ae06f3/6783b/1612269054283.png\" data-vdom-skip=\"true\" data-vdom-cache=\"true\" alt=\"错误的提示\" title=\"错误的提示\" name=\"images/1612269054283.png\" data-src=\"./images/1612269054283.png\" class=\"front_image\" loading=\"lazy\" srcSet=\"/acorns/static/234aba69c9e8ddcd2451a33bc0ae06f3/6783b/1612269054283.png 235w\" sizes=\"(max-width: 235px) 100vw, 235px\" data-action=\"zoom\" style=\"max-width: 100%;position: absolute;top:0;left:0;width: 100%;height:100%;object-fit: cover;object-position: center;\"></div><br><div class=\"story_image_caption \">错误的提示</div></div></div><p></p>\n<p class=\"xsj_paragraph xsj_paragraph_level_0\">原因就是 html 的 model 解析后就是 <code>&lt;div&gt;</code> , <code>{{</code>, <code>&lt;/div&gt;</code>,<code>}}</code> 和 <code>&lt;/div&gt;</code><br>\n而 mustache 的 model 解析后就是 <code>&lt;div&gt;</code>, <code>{{&lt;/div&gt;}}</code> 和 <code>&lt;/div&gt;</code></p>\n<p class=\"xsj_paragraph xsj_paragraph_level_0\">其中， html 的 <code>{{</code>, <code>&lt;/div&gt;</code>, <code>}}</code> 和 mustache 的 <code>{{&lt;/div&gt;}}</code> 是重叠的， 默认的 combine 为 false, 最终使用了 mustach 的 <code>{{&lt;/div&gt;}}</code> 方案，但 html 并不会因为 mustach 的覆盖，将解析再执行一篇， html 依然认为结尾的 <code>&lt;/div&gt;</code> 是有效的。</p>\n<blockquote class=\"markdown_blockquote\">\n<p class=\"xsj_paragraph xsj_paragraph_level_1\"><span class=\"xsj_placeholder_span\"></span>a secondary mode is run over the stream, along with the base mode, and can color specific pieces of text without interfering with the base mode</p>\n</blockquote>\n<p class=\"xsj_paragraph xsj_paragraph_level_0\">从官方的说明文档里，可以看出，这两个 mode 的运行是各自独立的，但最终结果会根据 combine 来决定是合并还是覆盖。</p>\n<h2 class=\"xsj_heading_hash xsj_heading xsj_heading_h2\" id=\"addonmodemultiplexjs20e6ba90e4bba3e7a081e8a7a3e69e90_2\"><div class=\"xiaoshujiang_element xsj_anchor\">\n  <a name=\"addonmodemultiplexjs20e6ba90e4bba3e7a081e8a7a3e69e90_2\" class=\"blank_anchor_name\"></a><a id=\"addonmodemultiplexjs20e6ba90e4bba3e7a081e8a7a3e69e90_2\" class=\"blank_anchor_id\"></a><a name=\"addonmodemultiplexjs-源代码解析\" class=\"blank_anchor_name\"></a><a id=\"addonmodemultiplexjs-源代码解析\" class=\"blank_anchor_id\"></a>\n</div>\n<span class=\"xsj_heading_content\">addon/mode/multiplex.js 源代码解析</span></h2>\n<p class=\"xsj_paragraph xsj_paragraph_level_0\"><code>addon/mode/multiplex.js</code> 里的 <code>multiplexingMode</code> 方法大概的实际效果：</p>\n<p class=\"xsj_paragraph xsj_paragraph_level_0\">遇到特定的开始<code>open</code> 或者结束<code>close</code> 标识，在这个范围内，完全独立的使用新的 mode 解析。</p>\n<p class=\"xsj_paragraph xsj_paragraph_level_0\">跟 <code>overlayMode</code> 不同的是， <code>multiplexingMode</code> 是互相独立的，内嵌的 mode 不受外部 mode 影响，外部的 mode 也不知道内部的 mode 做了什么。再拿上面 <code>overlayMode</code> 的测试代码说明。假设配置的 <code>multiplexMode</code> 的 open 是 <code>{{</code> ， close 是 <code>}}</code>, 这时候在 open 和 close 之间，即使有 <code>&lt;/div&gt;</code> 这样的代码，但它不会影响到外层的 html 显示效果。</p>\n<div class=\"xiaoshujiang_code_container\"><div data-processed=\"true\" class=\"xiaoshujiang_pre\"><div class=\"language-html hljs xml code_linenums xiaoshujiang_code\"><ol start=\"1\" class=\"ol_linenums\" style=\"counter-reset: lines 0;\"><li class=\"li_linenum \" date-linenum=\"1\"><span class=\"li_linenum_before_span li_linenum_before_span_hide\">1</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>{{<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>}}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><span style=\"user-select:none;display:none;\">&nbsp;</span><br class=\"code_line_break_hack_br\"><hr class=\"code_line_break_hack_hr code_line_break_hack\" style=\"margin:0;border:0;border-top:0;border-bottom:0;\"></li></ol></div></div></div>\n<p class=\"xsj_paragraph xsj_paragraph_level_0\"><code>multiplexMode</code> 可以包含都个 <code>subMode</code></p>\n<p class=\"xsj_paragraph xsj_paragraph_level_0\"><code>multiplexModex</code> 实际实现的就是类似 <code>html</code> 里可以嵌套 <code>javascript</code> 和 <code>css</code> 的效果。或者是 <code>markdown</code> 里类似代码块的效果。</p>\n<p class=\"xsj_paragraph xsj_paragraph_level_0\">那吗问题来了，为什么 CodeMirror 的开发人员，为什么不直接在 html 或者  markodnw mode 里使用 multiplexMode 来实现嵌套，而是要单独实现这种嵌套呢？原因可能是在 html / markdown 嵌套出来时， multiplexMode 这样的 addon 还法写出来，当写完这两套规则后，总结了经验，提炼出 multiplexMode 这样一个扩展吧；也有可能是 html / markdown 的嵌套规则比较复杂，单独写出来可能更好进行流程控制。</p>\n</div>\n\n","excerpt":"官方提供的教程\ndefineMode 里有使用到的方法\nnestMode 的定义和 mixMode addon 有什么区别呢？为什么不能在 markdonw Mode 里直接 nestMode texmode 而是要建议用 mixMode\naddon/model/overlay....","docType":"posts","slug":"study/inspect-codemirror-source","title":"CodeMirror 内部代码的研究","customCss":"","createDate":"February 01, 2021","updateDate":"February 02, 2021","tags":["学习","小书匠","codemirror","编辑器"]}},"pageContext":{"slug":"study/inspect-codemirror-source","zipPath":"/home/runner/work/acorns/acorns/posts/web/CodeMirror 内部代码的研究.zip","prev":{"title":"2019-11-28 学会踩踏","docType":"posts","slug":"bike/2019-11-28 学会踩踏"},"next":{"title":"编写CodeMirror Modes详解","docType":"posts","slug":"https:/wwwcnblogscom/xmzzp/p/4318265html"},"pluginOptions":{"tagsPath":"/tags/","archivesPath":"/archives/","basePath":"/","commentType":"gitalk"},"basePath":"/"}},"staticQueryHashes":["2682448919","2682448919"]}